## Введение

Это ваша первая лаба в containerlab в рамках курса.
В ней вы попробуете поработать с базовым инструментарием который потребуется на протяжении всего курса, а если точнее:

1. Подготовите свою машинку для работы с системой containerlab.
2. Запустим "стартовую" лабораторию
3. Проведете настройку оборудования.
4. Самостоятельно протестируете корректность работы после настройки.
5. Запушите свою конфигурацию в ваш форк и убедитесь что все тесты пройдены успешно


## Шаг 1. Подготовка

Containerlab — это инструмент, который облегчает развертывание сетевых лабораторий с использованием контейнеризованных сетевых операционных систем. Он позволяет создавать виртуальные сети, состоящие из контейнеров, эмулирующих сетевые устройства, такие как маршрутизаторы и коммутаторы, в средах, поддерживающих контейнеризацию, например, Docker.

Containerlab работает под разными операционными системами, такими как debian, ubuntu, fedor, rhel и т.п.
Самый простой способ установки, это воспользоваться [quickstart мануалом](https://containerlab.dev/quickstart/) с официального сайта
По сути дела все сводится к запуску скрипта который сам поймет вашу ОС, и проведет установку.
```
curl -sL https://containerlab.dev/setup | sudo -E bash -s "all"
```

## Шаг 2. Запускаем лабу

В лабораторной уже лежит стартовая конфигурация (подключенные линки, ip адреса и т.п.)
Давайте запустим ее.
Для этого сначала форкаем репозиторий с проект с gitlab.

> Примечание: Fork (от английского `вилка` или `развилка`), это копия проекта, которую вы создаете в своей личной области.
> Это популярный способ дорабатывать проекты. Например, если вы хотите внести изменения в какой-то проект на Github, по умолчанию у вас нет доступа в репозиторий с правом вносить изменения. Популярной считается практика создания форка, внесения изменений в свою ветку, а потом подготовка набора изменений, который передается в рамках Merge Request (набор изменений).

Для создания форка:

1. Перейдите по адресу проекта https://noc-academy.gitlab.yandexcloud.net/deev13/labs
2. В правом верхнем углу нажмите на значок Fork или просто перейдите по этой [ссылке](https://noc-academy.gitlab.yandexcloud.net/deev13/labs/-/forks/new)
3. Появится окно создания форка, выберети namespace с именем вашего логина вида `yc-2503-**`
4. Выберите опцию `Only the default branch main`
5. В разделе `Visibility level` выберите `Private`.
6. Нажмите кнопку `Fork project`

Перейти в свой проект можно при помощи кнопки в левом верхнем углу `Search or go to...`. 
Когда вы нажмете, то будут показаны все доступные вам проекты, выбирайте тот, что расположен в области с вашим именем в начале.

Далее нажмите на кнопку `Code` в правом верхнем углу и скопируйте ссылку под надписью Clone with SSH.

В консоли выполните команду `git clone ссылка из предыдущего шага`

Далее перейдите в папку с первой лабой:

```
cd lab1
```

Запускаем скрипт, который запустит лабу и проведет небольшую донастройку.
```
sudo ./start.sh
```
Под капотом он выполнит
* `containerlab deploy --topo frrlab.yml` - команда которая запустит топологию, описанную в файле frrlab.yml
* `./FRR-vty-files.sh` - создаст пустые файл для конфигурации vtysh.conf (что бы frr образ не ругался:)
* `./PC-interfaces.sh` - настроит ip адреса и сети на наших виртуальных клиентах под alpine

## Шаг 3. Конфигурация лабы

В нашей лаборатории есть 3 маршрутизатора на frr и 3 компьютера.
Маршрутизаторы подключены друг к другу, однако не знают о сетях которые находятся за соседом.
Давайте настроим динамический протокол OSPF, который установит соседства и обменяется маршрутами.

Для этого по очереди настроим `clab-frrlab-router1`, `clab-frrlab-router2` и `clab-frrlab-router3`.

Заходим на 1-й маршрутизатор средствами docker
```
$ docker exec -it clab-frrlab-router1 vtysh

Hello, this is FRRouting (version 7.5.1_git).
Copyright 1996-2005 Kunihiro Ishiguro, et al.

router1# 
```
Мы попадем в консоль управления маршрутизатором. Настроим OSPF
```
configure terminal 
router ospf
 passive-interface eth3
 passive-interface lo
 network 192.168.1.0/24 area 0.0.0.0
 network 192.168.2.0/24 area 0.0.0.0
 network 192.168.11.0/24 area 0.0.0.0
 exit
exit
write
exit
```

Далее аналогично зайдем и настроим 2-й маршрутизатор
```
$ docker exec -it clab-frrlab-router2 vtysh

Hello, this is FRRouting (version 7.5.1_git).
Copyright 1996-2005 Kunihiro Ishiguro, et al.

router2# 
```
```
configure terminal 
router ospf
 passive-interface eth3
 network 192.168.1.0/24 area 0.0.0.0
 network 192.168.3.0/24 area 0.0.0.0
 network 192.168.12.0/24 area 0.0.0.0
 exit
exit
write
exit
```

И тоже самое на 3-м маршрутизаторе
```
$ docker exec -it clab-frrlab-router3 vtysh

Hello, this is FRRouting (version 7.5.1_git).
Copyright 1996-2005 Kunihiro Ishiguro, et al.

router3#
```
```
configure terminal 
router ospf
 passive-interface eth3
 network 192.168.2.0/24 area 0.0.0.0
 network 192.168.3.0/24 area 0.0.0.0
 network 192.168.13.0/24 area 0.0.0.0
 exit
exit
write
exit
```

Конфигурация завершена.

## Шаг 4. Тестирование

Давайте проверим все ли у нас получилось:
1. Зайдем на какой-нибудь маршрутизатор и посмотрим установились ли OSPF соседства (у нас должно быть два соседства)
На примере clab-frrlab-router1 все удачно. Видно что все поднялось
```
docker exec -it clab-frrlab-router1 vtysh

Hello, this is FRRouting (version 7.5.1_git).
Copyright 1996-2005 Kunihiro Ishiguro, et al.

router1# show ip ospf neighbor 

Neighbor ID     Pri State           Dead Time Address         Interface                        RXmtL RqstL DBsmL
10.10.10.2        1 Full/Backup       30.689s 192.168.1.2     eth1:192.168.1.1                     0     0     0
10.10.10.3        1 Full/Backup       37.950s 192.168.2.2     eth2:192.168.2.1                     0     0     0
```

2. Попробуем с PC1 попинговать PC2 и PC3. Давайте сделаем это разными способами
* Для пинга PC2, давайте запустим следующую команду
```
$ sudo docker exec clab-frrlab-PC1 ping 192.168.13.2
PING 192.168.13.2 (192.168.13.2): 56 data bytes
64 bytes from 192.168.13.2: seq=0 ttl=62 time=1.157 ms
64 bytes from 192.168.13.2: seq=1 ttl=62 time=0.065 ms
64 bytes from 192.168.13.2: seq=2 ttl=62 time=0.065 ms
```
Т.е. мы выполнили команду пинга с PC1 даже не заходя в него, воспользовавшись возможностями docker выполнять команды на контейнерах

* Для пинга PC3 мы зайдем на PC1 и запустим команды с него вручную
```
$ sudo docker exec -it clab-frrlab-PC1 /bin/sh
/ # ping 192.168.13.2
PING 192.168.13.2 (192.168.13.2): 56 data bytes
64 bytes from 192.168.13.2: seq=0 ttl=62 time=0.084 ms
64 bytes from 192.168.13.2: seq=1 ttl=62 time=0.089 ms
64 bytes from 192.168.13.2: seq=2 ttl=62 time=0.084 ms
^C
--- 192.168.13.2 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.084/0.085/0.089 ms
```

Видно что оба пинга прошли успешно.

## Шаг 5. Пушим в свою ветку и смотрим на результаты тестирования

Осталось только добавить измененные файлы в commit.

Для этого выполним команду `git status`. Команда покажет список измененных файлов.

Добавим файлы в коммит при помощи команды `git add filename`. Если для добавления файла не хватает прав, то можно добавить в начале команды `sudo`.

Далее делаем коммит `git commit -am "lab1"` и пушим в наш репозиторий

```
git push
```
Далее в веб-интерфейсе Gitlab переходим в раздел Build -> Pipelines.

Там вы увидите все ваши попытки и статусы завершения. В каждую задачу (jobs) можно "провалиться" и посмотреть что происходило внутри раннера.

Если пайплайн не запустился, то можно запустить его руками при помощи из этого раздела при помощи кнопки "New pipeline" с пустыми параметрами.

В случае успеха вы увидите при выполнении пайплайна что-то типа такого
```
╭─────────────────────┬──────────────────────┬─────────┬───────────────────╮
│         Name        │      Kind/Image      │  State  │   IPv4/6 Address  │
├─────────────────────┼──────────────────────┼─────────┼───────────────────┤
│ clab-frrlab-PC1     │ linux                │ running │ 172.20.20.7       │
│                     │ alpine:latest        │         │ 3fff:172:20:20::7 │
├─────────────────────┼──────────────────────┼─────────┼───────────────────┤
│ clab-frrlab-PC2     │ linux                │ running │ 172.20.20.3       │
│                     │ alpine:latest        │         │ 3fff:172:20:20::3 │
├─────────────────────┼──────────────────────┼─────────┼───────────────────┤
│ clab-frrlab-PC3     │ linux                │ running │ 172.20.20.4       │
│                     │ alpine:latest        │         │ 3fff:172:20:20::4 │
├─────────────────────┼──────────────────────┼─────────┼───────────────────┤
│ clab-frrlab-router1 │ linux                │ running │ 172.20.20.5       │
│                     │ frrouting/frr:v7.5.1 │         │ 3fff:172:20:20::5 │
├─────────────────────┼──────────────────────┼─────────┼───────────────────┤
│ clab-frrlab-router2 │ linux                │ running │ 172.20.20.6       │
│                     │ frrouting/frr:v7.5.1 │         │ 3fff:172:20:20::6 │
├─────────────────────┼──────────────────────┼─────────┼───────────────────┤
│ clab-frrlab-router3 │ linux                │ running │ 172.20.20.2       │
│                     │ frrouting/frr:v7.5.1 │         │ 3fff:172:20:20::2 │
╰─────────────────────┴──────────────────────┴─────────┴───────────────────╯
$ sleep 30
$ sudo python3 check.py
Первая проверка на наличие OSPF в конфигурации
True
Вторая проверка на наличие OSPF соседств на clab-frrlab-router1:
True

Cleaning up project directory and file based variables
00:01
Job succeeded
```

Если вы увидели это, поздравляем, вы великолепны!

Переходите к следующей лабе.
